This is the "elevator pitch" document for Programming++, our IT club.
# Who we are
We're two (and a half) students who love programming. That's it. We went to bolyai to learn more, but we quickly outgrew the school's lesson plan. When we started learning on our own, we realized we were stuck in beginner tutorials and meaningless code. We didn't know how to learn. Over the years we worked on this skill and now we want to distill our knowledge into this club. We want to continue the tradition and culture this school had; a passion to teach others and learn with them.
# Problem:
Our school's teaching system is broken. Curriculum planners are slow and inefficient and we are in an outdated system that is showing its age.
## Consequences of this problem:
- It takes the joy out of programming: Students come to this school because they WANT to learn about this, yet so many get discouraged after seeing the programming classes here
- It is not enough for today's world: The modern programming world requires coders and designers to be productive, and to know their tools. Our school barely teaches the fundamentals.
- Students get stuck waiting or are rushed ahead: The curriculum requires a strict timeline that makes it so students are either bored waiting for the next thing to learn or are in a class that is way too fast paced for them.
- Students don't learn to program, they learn to pass tests: Our school's classes are built around tests; you learn for the test and you are measured by the test. Yet some students are terrible at programming and they pass with flying colors and other students are amazing programmers yet they get bad marks. Are the test makers at fault or is it the tests themselves?
- Teachers are picked not by their programming skills, but by their diploma and willingness to torture themselves: Teachers in this school are amazing, but they're also misguided. Some of them do not possess the knowledge of today's tech world, and are stuck teaching incorrect things.
- Students are stuck on one path and can't choose what to learn: Modern programming lives in many branches, from website programming to programming electronics. Students are only offered a narrow selection of classes that they can learn from, and they don't have the option to take advanced classes in a field, only learning the basics.
# Our solution:
A local class, once a week, that focuses on filling the holes left by our school.
# How we imagine it:
- When: One class once a week
- Where: In the new building
- How long: One hour
- Things a student needs: Basic computer skills
# What they would learn:
Whatever they want! But the most important thing would be these skills:
- Git, GitHub and how to manage a good repository
- How to think like a programmer, algorithmic thinking and problem solving
- Basic syntax knowledge that they can carry into any language (this can be Python or JavaScript)
- Soft skills: How to research, how to read docs, how to use tutorials and learn on your own
- The Linux console and how to manage files, chain commands and write your own scripts
- Code editor knowledge and productivity tricks
These provide the base necessary to progress in today's world, and they serve as the foundation through which you can learn and build anything. These skills would be taught first, and what comes next is up to them. Ideally, we would like to touch on these areas of programming:
- ### Front end website development (HTML, CSS, JS and its popular libraries)
	Using The Odin Project as a foundation, we would teach students how to create their own documents containing text, how to style them with style sheets, and how to make them interactive with JavaScript. We would start at the basics, and go through the developer experience chronologically: first with no build tools, just plain files, and then introduce the problems build tools and packagers solve with them. At the end of the course, we expect a student to be able to create their own website, research any behavior they require using the MDN docs, and work with their own preferred framework.
- ### Lower level programming with memory safety in mind (C, C++, Rust, with examples of Assembly)
	With this course, we would like to teach the more theoretical side of programming, specifically memory management, programming styles, multi-threading and how a computer works at its core. This course would not equip you to make a project all on your own, rather it explores the side of programming that is the most dangerous if learned incorrectly. We would explore the trappings of C, how you can use C++ to manage these pitfalls and how Rust gives you the power to not worry about them. We would also explore how a computer understands the words we say to it, and learn about how a compiler translates those words into machine code. We expect a student to be able to read Assembly fluently (but not write it), a loose knowledge of how their programs are translated, and what the most critical mistakes they could make are.
- ### Intermediate and advanced programming design and principles
	While not pertaining to any one language, this course would teach the more complicated problem in programming: How do you design a program, or a full set of software, and how do you design it well? While knowing how to code and how to problem solve are valuable skills, a programmer still needs to design. They need to understand the pros and cons of a decision, what paradigm or style fits their needs and how to write contained, readable, changeable code for the future. This class would teach the big things: OOP and how to design with it, how to write programs that last and how to make programming fun. We expect a student to be able to write programs that are easily changeable, are well designed both in the user-space and in the code itself, and are written with joy.
# How we plan to teach this
Our main goal is to give students the power to learn and make. We can't teach everything, and we don't know everything. But if we can lead and inspire, then they will learn all they need on their own. 
We want to be as flexible as possible. Students won't be graded, they won't be reviewed, and they get to decide if they learned what they needed to learn. We want to give students their own timelines, allowing them to learn on their own pace. Since we aren't set on a fixed schedule, we can move on if everyone understands the lesson and slow down if they need more explanation. 
We are not teachers, we are students as well. We need to manage our time carefully, and plan our lessons ahead of time. 
We need to be transparent and clear to our students. We have limitations as well and we can't teach everything. If we don't know something well, we ask the students to research it themselves while we do too.
Projects: We would only give light feedback on projects. Our main goal with projects is to let students make something on their own and to let them try out their new skills. Students should review their own projects to see if they can apply what they have learned. Projects should be made personal, no two people's projects should look alike.
